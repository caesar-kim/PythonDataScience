# 1주차. 처음 ~ 2장 5절

## 서문
### 데이터 과학이란 무엇인가? (p.7)
- Drew Conway의 데이터 과학 벤 다이어그램으로 설명한 것.  
![image](https://github.com/user-attachments/assets/f12463ff-d789-4f79-ae55-4b254f7524b2)
- 데이터 과학은 근본적으로 여러 분야에 걸친 주제이다. 3가지의 개별 영역.
  - 통계전문가statistician: 점점 방대해져가는 데이터셋을 모델링하고 요약하는
  - 컴퓨터 과학자 computer scientist: 이 데이터를 효과적으로 저장, 처리, 시각화하는 알고리즘을 설계하거나 사용
  - 도메인 전문성: 적절한 질문을 공식화하고 그 대답을 맥락에 맞게 이해하는데 필요한
- 즉, 데이터 과학은 새로 배우는 지식 영역이 아닌 현재 자신의 전문분야에 적용 가능한 새로운 기술이다.
- 각 장의 구성
    - IPython과 Jupyter: 계산 환경 제공
    - NumPy: 복잡한 데이터 배열을 효율적으로 저장하고 처리하기 위한 ndarray 객체 제공
    - Pandas: labeled 혹은 columnar 데이터를 효율ㅈ거으로 저장하고 가공하는 DataFrame 객체를 제공
    - Matplotlib: 유연한 데이터 시각화
    - Scikit-Learn: 머신러닝 구현물 제공

## 01장. Jupyter: 파이썬에 날개를 달자
- 개인적으로 IPython과 텍스트 편집기(Emacs나 Atom 중에서) 함께 사용하는 것을 선호한다.
- IPython은 대화형 python interactive Python.
    - 이는 Jupyter 프로젝트와 밀접하게 연결되어 있음.
### 1-1. IPython과 Jupyter 시작하기 (p.2)
- 일반적으로는 세 가지 방법으로 작업한다.
    - 짧은 명령 시퀀스 시험 때는 IPython 셸 사용.
    - 더 긴 대화형 분석 작업이나 다른 사람과 콘텐츠 공유 시에는 Jupyter.
    - 재사용할 파이썬 패키지 만들 때는 Emacs나 VSCode 같은 IDE 사용.
    - 책에서는 앞 2가지만 다룰 것.
- IPython 셸 실행하기 (p.2)
- Jupyter 노트북 실행하기 (p.3)
    - IPython 셸 기반 그래픽 인터페이스. 풍부한 동적 디스플레이 기술 기반으로 만들어짐.
    - 텍스트, 시각화, 수학 공식, 자바스크립트 위젯도 파함하게 해준다.
    - 웹 브라우저로 조회하고 편집할 수 있지만, 코드 실행하려면 실행 중인 파이썬 프로세스와 연결해야 함.
    - 커널kernel이라는 이 프로세스 시작하려면 시스템 셸에서 다음 며령어 실행.
```python
$ jupyter notebook
```
-   
    - 이는 브라우저에서 볼 수 있는 로컬 웹 서버 실행.
    - 명령어 실행하면 기본 브라우저 열리고 자동으로 로컬 URL 찾아 들어감.
- IPython의 도움말과 문서 (p.4)
    - 데이터 과학에서 효과적인 전문가는 웹 검색 엔진이나 다른 도구로 모르는 정보를 효과적으로 찾아내는 것에 가깝다.
    - 패키지, 소스코드, 함수 인수나 옵션 등을 빠르게 볼 수 있는 방법들에 대해 알아본다.
- ?로 문서 확인하기
    - 객체에 대한 간결 요약 정보나 사용법이 담긴 docstring이라는 참조가 있다.
    - 이 정보에 접근하는 것이 help() 함수.
    - IPython은 단축키로 ? 문자를 도입함.
        - 객체, 함수, 객체 자체에 대해서도, 직접 만든 함수에 대해서도 동작한다.
        - 따라서 우리도 코드에 """ 의 인라인 문서를 추가하는 습관을 들여야 함.
- ??로 소스코드에 접근하기
    - 파이썬 말고 C나 다른 언어로 구현된 함수(주로 파이썬 내장 객체)는 ?와 똑같은 결과만 출력됨.
- 탭 자동완서으로 모듈 탐색하기
    - 개체 속성과 메소드 목록 반환하는 내장함수 dir이 있지만, 객체.<tab>을 하면 다른 속성들이 나온다.
    - 일부 글자만 입력하고 tab을 눌러도 해당 속성과 메소드를 찾아줌.
    - 관례 상 비공개 속성 표시할 때 앞에 밑줄을 사용한다. _누르고 tab을 눌러서 이 메소드를 찾을 수도 있다.
        - 이것은 double-underscore methods, dunder 메소드라고 한다.
    - 사용 가능한 임포트 확인할 때도 import tab으로 확인 가능.
    - 와일드카드 매칭도 가능. *를 사용.
- IPython 셸에서 사용할 수 있는 키보드 단축키 (p.10)
    - GNU Readline 라이브러리의 종속성을 통해 단축키 제공.
    - 탐색 단축키
        - ctrl a: 커서를 줄 맨 앞으로.
        - ctrl e: 커서를 줄 맨 뒤로.
        - ctrl b 또는 <- : 커서를 한 글자 뒤로
        - ctrl f 또는 -> : 커서를 한 글자 앞으로
    - 텍스트 입력 단축키
        - ctrl d: 다음 문자 삭제
        - ctrl k: 현재부터 마지막까지 잘라내기
        - ctrl u: 처음부터 커서 위치까지 잘라내기
        - ctrl y: 이전에 잘라낸 텍스트 붙여넣기 yank
        - ctrl t: 앞의 두 글자 위치 바꾸기
    - 명령어 이력 단축키
        - IPython 프로파일 디렉터리의 SQLite 데이터베이스에 저장된 전체 명령어 이력을 탐색 가능.
            - ctrl p 또는 위화살표: 이력에서 이전 명령어에 접근
            - ctrl n 또는 아래 화살표: 이력에서 다음 명령어에 접근
            - ctrl r: 명령어 이력을 재탐색## 01장. Jupyter: 파이썬에 날개를 달자
- 개인적으로 IPython과 텍스트 편집기(Emacs나 Atom 중에서) 함께 사용하는 것을 선호한다.
- IPython은 대화형 python interactive Python.
    - 이는 Jupyter 프로젝트와 밀접하게 연결되어 있음.
### 1-1. IPython과 Jupyter 시작하기 (p.2)
- 일반적으로는 세 가지 방법으로 작업한다.
    - 짧은 명령 시퀀스 시험 때는 IPython 셸 사용.
    - 더 긴 대화형 분석 작업이나 다른 사람과 콘텐츠 공유 시에는 Jupyter.
    - 재사용할 파이썬 패키지 만들 때는 Emacs나 VSCode 같은 IDE 사용.
    - 책에서는 앞 2가지만 다룰 것.
- IPython 셸 실행하기 (p.2)
- Jupyter 노트북 실행하기 (p.3)
    - IPython 셸 기반 그래픽 인터페이스. 풍부한 동적 디스플레이 기술 기반으로 만들어짐.
    - 텍스트, 시각화, 수학 공식, 자바스크립트 위젯도 파함하게 해준다.
    - 웹 브라우저로 조회하고 편집할 수 있지만, 코드 실행하려면 실행 중인 파이썬 프로세스와 연결해야 함.
    - 커널kernel이라는 이 프로세스 시작하려면 시스템 셸에서 다음 명령어 실행.
```python
$ jupyter notebook
```
-   
    - 이는 브라우저에서 볼 수 있는 로컬 웹 서버 실행.
    - 명령어 실행하면 기본 브라우저 열리고 자동으로 로컬 URL 찾아 들어감.
- IPython의 도움말과 문서 (p.4)
    - 데이터 과학에서 효과적인 전문가는 웹 검색 엔진이나 다른 도구로 모르는 정보를 효과적으로 찾아내는 것에 가깝다.
    - 패키지, 소스코드, 함수 인수나 옵션 등을 빠르게 볼 수 있는 방법들에 대해 알아본다.
- ?로 문서 확인하기
    - 객체에 대한 간결 요약 정보나 사용법이 담긴 docstring이라는 참조가 있다.
    - 이 정보에 접근하는 것이 help() 함수.
    - IPython은 단축키로 ? 문자를 도입함.
        - 객체, 함수, 객체 자체에 대해서도, 직접 만든 함수에 대해서도 동작한다.
        - 따라서 우리도 코드에 """ 의 인라인 문서를 추가하는 습관을 들여야 함.
- ??로 소스코드에 접근하기
    - 파이썬 말고 C나 다른 언어로 구현된 함수(주로 파이썬 내장 객체)는 ?와 똑같은 결과만 출력됨.
- 탭 자동완서으로 모듈 탐색하기
    - 개체 속성과 메소드 목록 반환하는 내장함수 dir이 있지만, 객체.<tab>을 하면 다른 속성들이 나온다.
    - 일부 글자만 입력하고 tab을 눌러도 해당 속성과 메소드를 찾아줌.
    - 관례 상 비공개 속성 표시할 때 앞에 밑줄을 사용한다. _누르고 tab을 눌러서 이 메소드를 찾을 수도 있다.
        - 이것은 double-underscore methods, dunder 메소드라고 한다.
    - 사용 가능한 임포트 확인할 때도 import tab으로 확인 가능.
    - 와일드카드 매칭도 가능. *를 사용.
- IPython 셸에서 사용할 수 있는 키보드 단축키 (p.10)
    - GNU Readline 라이브러리의 종속성을 통해 단축키 제공.
    - 탐색 단축키
        - ctrl a: 커서를 줄 맨 앞으로.
        - ctrl e: 커서를 줄 맨 뒤로.
        - ctrl b 또는 <- : 커서를 한 글자 뒤로
        - ctrl f 또는 -> : 커서를 한 글자 앞으로
    - 텍스트 입력 단축키
        - ctrl d: 다음 문자 삭제
        - ctrl k: 현재부터 마지막까지 잘라내기
        - ctrl u: 처음부터 커서 위치까지 잘라내기
        - ctrl y: 이전에 잘라낸 텍스트 붙여넣기 yank
        - ctrl t: 앞의 두 글자 위치 바꾸기
    - 명령어 이력 단축키
        - IPython 프로파일 디렉터리의 SQLite 데이터베이스에 저장된 전체 명령어 이력을 탐색 가능.
            - ctrl p 또는 위화살표: 이력에서 이전 명령어에 접근
            - ctrl n 또는 아래 화살표: 이력에서 다음 명령어에 접근
            - ctrl r: 명령어 이력을 재탐색

### 1-2. 향상된 대화형 기능 (p.13)
- IPython 매직 명령어 (p.13)
    - 매직 명령어는 맨 앞에 % 기호를 붙임. % 하나 붙이는 라인 매직과 %%를 붙이는 셀 매직이 있다.
    - 코드 실행 시간 측정: %timeit
        - 이 명령어 뒤에 함수를 쓰면 시간을 측정해줌. 
    - %magic으로 사용 가능 매직 함수 목록 확인 가능.
    - %Ismagic으로 자기만의 매직함수 정의 가능.
- 입력/출력 이력 (p.15)
    -  IPython의 In과 Out 객체
        - In은 명령어를 순서대로 기록하는 리스트이다.
        - Out 객체는 리스트가 아니라 입력 번호를 출력과 매핑하는 딕셔너리다.
            - import와 print 같이 None을 반환하는 명령어는 Out에 추가되지 않는다.
        - 과거 결괏값을 활용 가능 Out[2] + Out[3] 같이 계산.
    - 밑줄 표시 단축키와 이전 출력값
        - print(_) 처럼 이전 출력값을 알려준다.
        - 밑줄_을 여러번 써서 그 이전 그그 이전까지 알아낼 수 있다. 밑줄 세 개까지만 제공.
        - Out[x]를 _x로 줄여서 쓸 수 있다.
    - 출력값 숨기기
        - 그 줄 마지막에 ; 세미콜론을 붙이면 화면에 표시되지 않고 Out 딕셔너리에 저장되지도 않는다.
    - 입력값 여러 개 한 번에 접근하려면 %histroy 매직명령어 사용.
    - 유사하게 명령어 이력 중 일부 재실행하는 %rerun이나 명령어 이력 중 일부 집합을 파일에 저장하는 %save도 있다.
- IPython과 셸 명령어 (p.18)
    - 여러 창을 교대로 사용하는 점을 방지하기 위해 IPython 터미널에서 바로 셸 명령어 실행하는 구문 제공.
    - 느낌표 ! 뒤에 나타나는 것은 파이썬 커널이 아닌 시스템 명령줄에 의해 실행된다.
    - 셸이란?
        - 셸은 컴퓨터와 텍스트로 작용하는 한 가지 방식.
        - 일련의 텍스트 입력으로 컴퓨터를 제어했다.
    - IPython에서의 셸 명령어
        - 명령어 앞에 ! 를 붙여 사용 가능.
### 1-3. 디버깅 및 프로파일링 (p.23)
- 에러와 디버깅 (p.23)
    - 예외 제어: %xmode
        - 인터프리터가 예외를 발견하면 traceback 제공. 예외 시 출력 정보 양을 제어할 수 있다.
        - 정보 양 낮은 것부터 Plain, Context, Verbose가 있다.
    - ipdb 디버거를 통해 코드를 한 줄 씩 읽어서 오류 확인 가능.
    - 예외 만나고 %debug 호출하면 예외 발생 지점에 대화형 디버깅 프롬프트를 자동으로 연다.
    - 디버거 자동 실행은 %pdb 매직 함수로 가능.
- 코드 프로파일링 및 시간 측정 (p.28)
    - 처음부터 시간 신경 쓰면 안 됨. 코드가 제대로 동작할 때 효율성에 대한 고민이 좋다.
- IPython 추가 참고 자료 (p.35)

## 02장. NumPy 소개
-  
    - 모든 데이터는 숫자 배열로 다루는 것이 도움이 될 것. 이미지나 사운드 클립도 배열로 나타낼 수 있다.
    - NumPy Numerical Python는 list와 비슷하지만 배열 규모가 커질수록 더 효율적.
    - 별칭 alias 는 np이다.
### 2-1. 파이썬의 데이터 타입 이해하기 (p.39)
-  
    - 데이터 배열이 파이썬에서 어떻게 처리되는지 보고, np가 어떻게 개선하는지 볼 것.
        - 파이썬은 다른 언어와 다르게 모든 변수를 명시적으로 선언할 필요가 없음.
        - 이것은 파이썬의 유연성 이지만, 그 변수가 그 값 이상의 무언가를 나타낸다는 뜻이기도 함.
- 파이썬 정수는 정수 이상이다 (p.40)
    - 표준 파이썬은 C로 구현되어 있다. 파이썬 그 자체가 위장한 C 구조체라는 것.
    - 파이썬의 정수long 타입 정의도 C로 보면 4가지 구성요소로 이루어져 있다.
    - C에서의 정수는 메모리 위치를 가리키는 레이블이고, 파이썬 정수는 그 정수를 포함한 바이트를 포함한 파이썬 객체 정보까지 포함하는 메모리 위치를 가리키는 포인터이다.
    - 덕분에 파이썬에서 동적으로 자유롭게 코드 작성 가능. 하지만 여기에는 비용이 발생할 수 밖에 없다.
- 파이썬 리스트는 리스트 이상이다 (p.41)
    - 동적 타이핑dynamic typing 덕분에 서로 다른 데이터 타입 요소를 담은 리스트를 만들 수도 있다.
    - 이러한 유연성에는 비용이 따른다. 리스트의 각 항목이 완전히 다른 파이썬 객체가 되는 것.
    - 따라서 모든 데이터가 같은 타입이면 고정 타입 배열에 데이터 저장하는 것이 더 효율적.
    - np는 유연성은 줄였지만, 데이터를 저장, 가공하기에 더 효과적.
- 파이썬의 고정 타입 배열 (p.43)
    - 파이썬도 고정 타입 데이터 저장을 위해서 array 모듈을 제공한다.
    - 그러나 np의 ndarray가 더 유용.
- 파이썬 리스트에서 배열 만들기 (p.43)
```python
import numpy as np
np.array([1, 4, 2, 5, 3])
# 파이썬 리스트와 달리 np에서는 모든 요소가 같은 타입이어야 함. 일치하지 않으면 상위 타입으로 자동으로 취하게 된다.
# 명시적으로 결과 배열의 데이터 타입 설정하려면 dtype 사용.
np.array([1, 2, 3, 4], dtype='float32')
# np 배열은 명시적으로 다차원이 가능하다.
np.array([range(i, i+3) for i  in [2, 4, 6]])
# 이러한 내부 리스트는 행으로 취급된다.
```
- 처음부터 배열 만들기 (p.44)
```python
# 규모가 큰 배열은 np 내장 루틴을 통해 처음부터 배열 생성하는 것이 더 효율적.
# 0으로 채운 길이 10의 정수 배열 만들기
np.zeros(10, dtype=int)

# 1로 채운 3X5 부동 소수점 배열 만들기
np.ones((3, 5), dtype=float)

# 3.14로 채운 3X5 배열 만들기
np.full((3, 5), 3.14)

# 선형 등차수열로 채운 배열 만들기 0부터 20까지 2씩 증가.
np.arrange(0, 20, 2)

# 0~1 사이에 일정 간격 가진 5개 값으로 채운 배열 만들기
np.linspace(0, 1, 5)

# 균등 분포된 3X3 배열 만들기. 0~1 사이 난수로 채운다.
np.random.random((3, 3))

# 정규분포 평균0, 분산1인 난수로 채운 3x3 배열 만들기
np.random.normal(0, 1, (3, 3))

# [0, 10] 구간 임의 정수로 채운 3x3 배열 만들기
np.random.randint(0, 10, (3, 3))

# 3x3 단위 행렬 만들기
np.eye(3)

# 3개 정수 가지는 초기화되지 않은 배열 만들기.
# 값은 해당 메모리 위치에 이미 존재하고 있는 값으로 채움
np.empty(3)
```
- NumPy 표준 데이터 타입 (p.45)
    - np는 한가지 타입만 담고 있어서 그 타입과 그 타입 제약사항을 자세히 아는 것이 중요하다.
    - np도 C로 구현되어서 C언어 사용자에게 익숙할 것.
### 2-2. NumPy 배열의 기초 (p.47)
-  
    - 파이썬에서 데이터 처리는 np 배열 처리와 거의 비슷하다.
    - pandas도 np배열 기반으로 만들어졌다.
- NumPy 배열 속성 지정 (p.47)
    - 난수 생성기로 난수 배열을 정의한다. 똑같은 배열이 생성되도록 시드값 설정할 것.
```python
import numpy as np
np.random.seed(0)
x1 = np.random.randint(10, size=6) # 1차원 배열
x2 = np.random.randint(10, size=(3, 4)) # 2차원 배열
x3 = np.random.randint(10, size=(3, 4, 5)) # 3차원 배열
# 각 배열의 속성은 ndim(차원 개수), shape(차원 크기), size(전체 배열 크기), dtype(각 요소 타입)을 가진다.
```
- 배열 인덱싱: 단일 요소에 접근하기 (p.48)
```python
# 파이썬 리스트 인덱싱과 유사하다. 0부터 시작하고 꺽쇠 안에 인덱스 지정하면 됨.
# 다차원 배열에서는 콤마로 구분된 인덱스 튜플로 접근 가능.
x2[2, 0]    # 3번째 행의 1번째 열 출력.
x2[2, 0] = 12    # 해당 위치 값을 수정할 수도 있다.
# 고정 타입을 갖기 때문에 정수 배열에 float을 삽입하면 소수점 아래는 잘라버리게 됨.
```
- 배열 슬라이싱: 하위 배열에 접근하기 (p.49)
```python
# 꺽쇠와 : 콜론으로 slice할 수도 있다. 파이썬 리스트 구문과 동일하다.
# x[start:stop:step]
# 기본 값은 x[0, 차원크기, 1] 이다.

# 1차원 하위 배열
x[:5]    # 1~5번까지. 0 1 2 3 4
x[5:]    # 5 이후 5 6 7 ...
x[::2]    # 2개씩 건너 뛰기 0 2 4  6 8
x[1::2]    # 1번 인덱스부터 시작해서 2개씩 건너 뛰기 1 3 5 7 9
# step이 음수면 혼동이 있을수도 있다. 이 때는 start와 stop 기본값이 서로 바뀐다.
x[::-1]    # 모든 것을 거꾸로 나열
x[5::-2]    # 인덱스 5부터 하나 걸러 하나씩 거꾸로 나열.

# 다차원 하위 배열
# 콤마로 구분된 다중 슬라이스로 똑같은 방식으로 동작한다.
x2[:2, :3]     # 2개의 행과 3개의 열
x2[:3, ::2]    # 3개의 행과 열은 한 열 걸러 하나씩. 즉 1 3 5.. 열만 출력.
# 한 가지 공통으로 필요한 루틴은 배열의 단일 행안 열에 접근하는 것이다.
x2[:, 0])    # x2의 첫 번째 열

# copy가 아닌 view로서의 하위 배열
# 배열 슬라이스는 배열 데이터의 copy가 아니라 view일 뿐이다. 파이썬 슬라이싱과 다른 점 중 하나.
# 즉 하위 배열을 수정하면 원래 배열까지 변경된다는 것.
# 이 점은 큰 데이터셋 다룰 때 유용.

# 배열의 사본 만들기
# 하지만, 데이터를 명시적으로 복사하는 것이 더 유용할 때가 있다.
x2_copy = x2[:2, :2].copy()
```
- 배열 재구조화 (p.53)
```python
# 배열의 형상을 변경하기
grid = np.arange(1, 10).reshape((3, 3))    # 3X3 행태로 들어간다. 123, 456, 789
# 이 때 초기 배열과 변경할 배열간 규모가 일치해야 한다.

# 1차원 배열은 매트릭스로 전환하는 것. reshape 매소드나 슬라이스 연산 내에 newaxis 키워드로 할 수도 있다.
x = np.array([1, 2, 3])
x.reshape((1, 3))
x[np.newaxis, :]    # 위 둘의 동작은 같다.
```
- 배열 연결 및 분할 (p.54)
```python
# 지금까지는 모두 단일 배열 동작이었고, 여러 배열을 결합, 분할도 가능하다.
# 배열 연결은 주로 np.concatenate, np.vstack, np.hstack으로 한다.
# concatenate는 튜플이나 배열의 리스트를 첫 인수로 취한다.
x = np.array([1, 2, 3])
y = np.array([3, 2, 1])
np.concatenate([x, y])    # 결과는 1 2 3 3 2 1
# 둘 이상의 배열도 한 번에 연결 가능.

# 2차원도 가능. 첫 번재 축을 따라 연결  grid는123 456.
np.concatenate([grid, grid])    # 123 456 123 456
# 두 번째 축을 따라 연결. 0부터 시작하는 인덱스 방식
np.concatenate([grid, grid], axis=1)    # 123123 456456

# 차원이 혼합되면 vertical stack이나 horizontal stack을 사용하는 것이 더 명확하다.
np.vstack([x, grid])
np.hstack([grid, y])

# 배열 분할: np.split, np.hsplit, np.split으로 구현. 분할 지점의 인덱스를 전달하면 된다.
x = [1, 2, 3, 99, 99, 3, 2, 1]
x1, x2, x3 = np.split(x, [3, 5])    # 123 9999 321로 분할된다.

# N개의 분할점은 N+1개의 하위 분할을 만든다.
```
### 2-3. NumPy 배열 연산: 유니버설 함수 (p.56)
-  
    - np 배열 연산은 아주 빠르거나 아주 느릴 수 있다.
    - 빠르게 만드는 핵심은 벡터화 연산 vectorized 연산.
    - 일반적으로 np의 유니버설 함수universal functions Ufuncs로 구현됨.
- 루프는 느리다 (p.57)
    - 파이썬의 기본 구현 CPython에서 몇 가지 연산은 매우 느리다.
    - 파이썬이 동적인 인터프리터 언어이기 때문. 타입이 유연하다는 사실은 결국 C처럼 효율적인 머신코드로 컴파일 되지 못한다는 뜻.
    - 극복하려는 시도들은 그렇게 성공적이지 못하였다.
    - 파이썬은 수많은 작은 연산이 반복되는 상황에서 확연히 느리다.
    - 예를 들면 배열을 반복해서 각 요소를 조작하는 것. 계산할 때마다 객체 타입을 확인하고 타입에 맞는 적절한 함수를 동적으로 검색해야 하기 때문.
- Ufuncs 소개 (p.58)
    - np는 이러한 정적 타입 체계를 가진 컴파일된 루틴에 편리한 인터페이스 제공. 이를 벡터화 연산이라고 함.
    - 이 벡터화 방식은 루프를 np의 기저를 이루는 컴파일된 계층으로 밀어넣음으로써 훨씬 빠르게 실행되도록 설계되었다.
    - 배열에 연산을 수행해 각 요소에 적용하여 수행 가능.
    - np에서 벡터화 연산은 np배열 값에 반복된 연산을 빠르게 수행하는 것이 목적인 UF를 통해 구현된다.
    - 매우 유연해서 배열끼리의 연산까지도 가능. 다차원에서도 동작.
    - 배열 크기가 커질수록 UF와 파이썬 루프의 차이는 점점 커진다.
- NumPy 유니버설 함수(Ufuncs) (p.59)
    - UF는 단향 UF와 이항 UF로 두 종류가 있다.
```python
# 배열 산술 연산
# np Ufuncs는 파이썬 기본 산술 연산자를 사용한다.
# 배열끼리의 곱셈, 덧셈, 나눗셈, 뺄셈, 지수, 나머지% 연산자까지 사용 가능.
# 이러한 산술 연산은 사용상 편의를 위해 np에 내자된 특정 함수를 감싼 것. +연산은 np.add 함수의 wrapper래퍼 함수이다.
# 이 외에도 부울, 비트 단위 연산자도 있다.

# 절댓값 함수. 두 가지 모두 같은 동작. 원소의 절댓값을 반환한다.
np.absolute(x)
np.abs(x)

# 삼각함수
theta = np.linspace(0, np.pi, 3)     # 각도 배열을 먼저 저으이
np.sin(theta)    # sin theta 정의
# 이 값들은 기계 정밀도 내에서 계산되어서 0이어야 하는 값이 언제나 완전한 0이 되지는 않는다. 역삼각 함수도 사용 가능.

# 지수와 로그
np.exp(x)    # e의 x승
np.exp2(x)       # 2의 x승
np.power(3, x)    # 3의 x승
np.log(x)    # np.log2, np.log10도 가능
np.expm1(x)
np.log1p(x)    # 이 두 함수는 x가 매우 작을 때 더 정확한 값을 내놓는 특화된 버전.

# 쌍곡선 삼각함수, 비트 연산, 비교 연산자, 라디안, 반올림, 나머지 등 다양한 기능들이 있다.
# 서브 모듈인 scipy.special이 있다. 잘 알려지지 않은 함수들은 여기서 구현할 가능성이 크다.
```
- 고급 Ufuncs 기능 (p.64)
```python
# 출력지정
# 대규모 연산에서 연산 결과를 저장할 배열을 지정하는 것이 유용할 때가 있음.
# 임시 배열 생성 말고 지정한 배열에 원하는 메모리 위치에 직접 연산 결과를 쓸 수 있다. out인수로 출력 지정.
np.multiply(x, 10, out=y)

# 배열 뷰와도 함께 사용 가능. 연산 결과를 지정된 배열 요소에 하나씩 뛰어넘어서 기록 가능.
np.power(2, x, out=y[::2])
# 대규모 배열에서 out 인수를 신중하게 사용해서 절약하는 메모리가 상당히 크다.

# 집계 (이항 UF에서)
# 배열을 특정 연산으로 축소할 때 reduce 메소드. 결과가 하나 남을때까지 반복 적용.
x = np.arrange(1, 6)
np.add.reduce(x)

# 모든 배열 요소의 곱을 반환한다. 원소끼리 곱한 것.
x = np.multiply.reduce(x)

# 계산 중간 결과 모두 저장하려면 accumulate
np.add.accumulate(x)
# 그 결과를 계산하는 전용 np 함수 np.sum, np.prod, np.cumsum, np.cumprod도 있다.

# 외적
# outer 메소드로 곱 테이블을 만들 수 있다.
np.multiply.outer(x, x)
# ufunc.at과 ufunc.reduceat 메소드도 매우 유용.
```
- Ufuncs: 더 알아보기 (p.64)
### 2-4. 집계: 최솟값, 최댓값, 그리고 그 사이의 모든 것 (p.66)
대용량 데이터에 직면했을 때 가장 궁금 한 것은 요약 통계. 이러한 내장 집계 함수들에 대한 것.
- 배열의 값의 합 구하기 (p.66)
```python
# 가장 간단한 것은 합치는 것.
np.sum(L)
# 이 기능은 파이썬에도 있지만 np에서 훨씬 속도가 빠르다. sum과 np.sum은 완벽히 동일한 것은 아니라 혼선이 있을수도.
```
- 최솟값과 최댓값 (p.67)
```python
min(L), max(L)    # 최솟값과 최댓값에 대한 파이썬 함수
np.min(L), np.max(L)    # 비슷한 np 함수. 속도는 더 빠르다.
L.min(), L.max(), L.sum()    # 더 간단하게 작성도 가능.

# 다차원 집계
# 가장 보편적인 집계는 행과 열을 기준으로 하는 것.
M.sum()    # 기본적으로 합치기
M.min(axis=0)    # 축을 지정할 수 있다. 각 열의 최솟값을 찾으려면 =0으로 지정.
M.max(axis=1)    # =1은 각 행에 대한 것.
# axis 키워드는 반환할 차원이 아닌 축소할 차원이다. 0을 입력한다는 것은 첫 번째 축을 축소한다는 것. 2차원이라면 열들의 값이 집계된다는 것.

# 기타 집계함수
# 누락을 무시하라는 NaN 안전 모드도 있다.
```  
![image](https://github.com/user-attachments/assets/5dda0f44-4cff-45f3-a300-b0456e646884)  

- 예제: 미국 대통령의 평균 신장은 얼마일까? (p.70)
```python
!head -4 data/president_heights.csv

import pandas as pd
data = pd.read_csv('data/president_heights.csv')
heights = np.array(data['height(cm)'])
print(heights)

# 다양한 요약 통계 계산
print("Mean height:   ", heights.mean())
print("Standard deviation:   ", heights.std())
print("Minimum height:   ", heights.min())
print("Maximum height:   ", heights.max())
# 사분위수도 계산가능
np.percentile(heights, 25)
np.median(heights)
np.percentile(heights, 75)

# 시각적으로 표현하는 것이 유용할 수도
%matplotlib inline
import matplotlib.pyplot as plt
import seaborn; seaborn.set()  # 플롯 스타일 설정
plt.hist(heights)
plt.title('~~~')
plt.xlabel('height (cm)')
plt.ylabel('number');
```
### 2-5. 배열 연산: 브로드캐스팅 (p.72)
벡터화 연산의 또 다른 방법은 Numpy의 브로드캐스팅 기능 사용. 이것은 단지 다른 크기의 배열에 이항 유니버설 함수(덧셈, 곱셈, 뺄셈 등)를 적용하기 위한 규칙의 집합일 뿐.
- 브로드캐스팅 소개 (p.72)
  - 같은 크기의 배열에서 이항 연산은 배열의 요소 단위로 수행된다.
```python
import numpy as np
a = np.array([0, 1, 2])
b = np.array([5, 5, 5])
a + b   # 답 5, 6, 7
# 브로드캐스팅은 이러한 유형의 이항 연산을 서로 다른 크기 배열에서 수행 가능.
# 배열에 스칼라도 쉽게 더할 수 있다.
a + 5   # 답 5 6 7
# 값 5를 5 5 5로 확장하거나 복제하고 그 결과를 더하는 연산이 발생한다고 생각하면 됨.
# 그러나 실제 복제가 발생하지는 않음.
```
- 브로드캐스팅 규칙 (p.74)
  - 규칙1: 두 배열의 차원수가 다르면 더 적은 차원 수의 배열 형상의 앞쪽(왼쪽)을 1로 채운다.
  - 규칙2: 두 배열 형상이 어떠한 차원에서도 일치하지 않으면 해당 차원의 형상이 1인 배열이 다른 형상과 일치하도록 늘어난다.
  - 규칙3: 임의의 차원에서 크기 불일치, 1도 아니라면 오류가 발생한다.
- 실전 브로드캐스팅 (p.77)
```python
# 배열 중앙 정렬하기
# ufunc를 통해 파이썬 루프를 명시적으로 작성하지 않아도 되는 사실을 알았다. 브로드캐스팅은 이 능력을 확장한다.
X = np.random.random((10, 3))

Xmean = X.mean(0)  # 첫 번째 차원의 특성별 평균값 계산

X_centered = X - Mean  # 평균값을 빼서 X 배열을 중앙 정렬한다. 이것이 브로드캐스팅.

# 2차원 함수 플로팅하기
# 2차원 함수 기반 이미지 그릴 때도 유용.
# x와 y는 0~5까지 50단계로 나눈 배열이다.
x = np.linspace(0, 5, 50)
y = np.linspace(0, 5, 50)[:, np.newaxis]
z = np.sin(x) ** 10 + np.cos(10 + y * x) * np.cos(x)

%matplotlib inline
import matplotlib.pyplot as plt
plt.imshow(z, origin='lower', extent=[0, 5, 0, 5], cmap='viridis')
plt.colorbar();
```
